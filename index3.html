<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>

<body>
	<div><h1>Budgeten 2015</h1></div>

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js" type="text/javascript" ></script>
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="getbudget.js" type="text/javascript"></script>
	<script src="colorbrewerMod.js" type="text/javascript"></script>
	<script src="colorbrewer.js" type="text/javascript"></script>

	<div id="main"></div>
	<button type="button" id="colorbutton">Change view</button>

	<h2>Skillnaderna</h2>
	<div id="details"></div>

	<script>

	jQuery(init);

	function init() {
		var margin = {top: 40, right: 10, bottom: 10, left: 10},
			width = 980 - margin.left - margin.right,
			height = 600 - margin.top - margin.bottom;

		var savedRoot;
		var percentColor = true;

		// treemap är funktionen som genererar vårt data, tar root (vårt object).
		var treemap = d3.layout.treemap()
			.children(function(d, depth) { return depth ? null : d.children; })
			.size([width, height])
			.sticky(true)
			.round(false)
			.value(function(d) { return d.size; })
			.sort(function comparator(a, b) { return a.value - b.value; });

		// var div lägger till en div till vår main div, som vi sedan kan rita i
		var div = d3.select("#main").append("div")
			.attr("id", "chart")
			.style("position", "relative")
			.style("width", (width + margin.left + margin.right) + "px")
			.style("height", (height + margin.top + margin.bottom) + "px")
			.style("margin-left", margin.left + "px")
			.style("margin-top", margin.top + "px");

		// on click of color button ropar på draw tree, och färgerna sätts om
		jQuery("#colorbutton").click(function() {
			percentColor = !percentColor;
			drawtree(savedRoot);
		});


		// ritar vår grejj
		function drawtree(root) {
			savedRoot = root;

			// spara data som gått genom treemap i data
			var data = treemap.nodes(root);
			console.log(data);

			var ratio = data[0].area/data[0].value;
			var fullvalue = data[0].value;
			console.log(fullvalue);
			var fulldiff = -17100000;
			var oldfullvalue = fullvalue + fulldiff;

			var procentdiffish = function(d) {
				return (d.value + d.diff*1)/oldfullvalue - d.value/fullvalue;
			}

			// gör en linear scale för färg, som tar ut minsta och största diff
			var o = d3.scale.linear()
				.domain([
					d3.min(data, function(d) { return d.diff*1; }),
					d3.min(data, function(d) { return d.diff*1; })*1/3,
					d3.min(data, function(d) { return d.diff*1; })*2/3,
					-1,
					0,
					1,
					d3.max(data, function(d) { return d.diff*1; })*1/3,
					d3.max(data, function(d) { return d.diff*1; })*2/3,
					d3.max(data, function(d) { return d.diff*1; })
				])
				.range(colorbrewerMod.GnRd[9]);

			// linear scale för skillnad i procent diff
			var u = d3.scale.linear()
				.domain([
					-0.1
					-0.01,
					-0.001,
					-0.000000000000001,
					0,
					0.001,
					0.0000000000000001,
					0.01,
					0.1
				])
				.range(colorbrewerMod.GnRd[9]);

			// funktion som kollar om percentcolor är "true", vilket avgör vilken färg som divsen får
			var colorfun = function(d) {
				return percentColor
					? u(procentdiffish(d))
					: o(d.diff);
			}

			var textfun = function(d) {
				return percentColor ? "<p class='line1'>" + (Math.round(d.value * 0.000001)) + "</p>" +
						"<p class='line2'> from " + Math.round(d.value/fullvalue * 1000)/10 + "% to " + Math.round((d.value + d.diff*1)/ oldfullvalue *1000)/10 + "% </p>" +
						"<p class='line3'>" + nameish(d) + "</p>"

					: "<p class='line1'>" + (Math.round(d.value * 0.000001)) + "</p>" +
						"<p class='line2'>" + addplus(d) + diffish(d) + " </p>" +
						"<p class='line3'>" + nameish(d) + "</p>";
			}

			// bound modell. bound binder data till alla classed node
			var bound = d3.select('#chart')
				.selectAll(".node")
				.data(data);

			bound.select('div.text')
				.html(function(d) {
					if (d.value > 10000000) {
						return textfun(d);
					}
				});

			// update - sker efter enter.append - sker alltså även vid uppdatering
			bound.select('div.content')
				.style("background", colorfun);

			// new - enter the data
			bound.enter().append('div')
				.attr("class", "node")
				// position the divs
				.style("left", function(d) { return d.x + "px"; })
				.style("top", function(d) { return d.y + "px"; })
				.style("width", function(d) { return Math.max(0, d.dx) + "px"; })
				.style("height", function(d) { return Math.max(0, d.dy) + "px"; })
				.style("background", "white")

				//now we append divs to the divs
				.append('div')
					.attr("class", "content")
					.style("margin", "0px")
					.style("opacity", 1)
					.style("background", "#b3e2cd")
					.style("border-radius", function(d) { if (d.value > 12000000) {
							return "4px";
						} else {
							return "2px";
						}
					})
					.style("height", function (d) {
						return (d.dy - 2) + "px";
					})
					.style("width", function (d) {
						return (d.dx - 2) + "px";
					})

				.append('div')
					.classed('text', true)
					// and we append some text
					.html(function(d) {
						if (d.value > 10000000) {
							return "<p class='line1'>" + (Math.round(d.value * 0.000001)) + "</p>";
						}
					})
				;




			// Rita ut alla småboxar
			// New - enter the data
			var lista = [{
				diff: 17100000,
				diffside: Math.pow(Math.abs(17100000 * 1) * ratio, 1/2)}
			];
			var xOffset = 0;

			data.forEach( function(d) {
				if (d.children == null) {
					d.diffside = Math.pow(Math.abs(d.diff * 1) * ratio, 1/2);
					lista.push(d);
				}
			});

			lista.sort(function comparator(a, b) {
				return Math.abs(b.diff) - Math.abs(a.diff);
			});

			lista.forEach( function(d) {
				d.xOffset = xOffset;
				xOffset += (d.diffside + 5);
			});

			var height2 = 120;
			var margin2 = {top: 10, right: 10, bottom: 10, left: 10};

			// Var div lägger till en div till vår main div, som vi sedan kan rita i
			var div2 = d3.select("#details").append("div")
				.attr("id", "chart2")
				.style("position", "relative")
				.style("width", (width + margin2.left + margin2.right) + "px")
				.style("height", (height2 + margin2.top + margin2.bottom) + "px")
				.style("left", margin2.left + "px")
				.style("top", margin2.top + "px");

			// Ny, bound modell. bound binder data till alla classed node
			var bound2 = d3.select('#chart2')
				.append('svg')
				.attr('width', '100%')
				.attr('height', '100%')
				.selectAll(".node")
				.data(lista);

			bound2.enter()
				.append('g')
					.attr("transform", function(d) {
						return "translate(" + d.xOffset + "," + (height2 - d.diffside) + ")";
					})
					.append('rect')
					.attr("fill", function(d) { return o(d.diff); })
					.attr("width", function (d) {
						return d.diffside;
					})
					.attr("height", function (d) {
						return d.diffside;
					})
			;
		};

		var nameish = function(d) {
			if (d.value < 21000000) {
				return (d.name.split(/\s+/).slice(0,1).join(" ").replace(/,\s*$/, "") + "...");
			} else {
				return d.name;
			}
		};

		var diffish = function(d) {
			if (d.diff*1 != 0) {
				return ((Math.round(d.diff*1 * 0.001)) + " miljoner");
			} else {
				return "Oförändrad"
			}
		};

		var addplus = function(d) {
			return d.diff*1 > 0 ? "+" : "";
		};


		getbudget(drawtree);

	}

	</script>

</body>
</html>
